// 2.2.4 new绑定
// 这是第四条也是最后一条 this 的绑定规则，在讲解它之前我们首先需要澄清一个非常常见
// 的关于 JavaScript 中函数和对象的误解。
// 在传统的面向类的语言中，“构造函数”是类中的一些特殊方法，使用 new 初始化类时会
// 调用类中的构造函数。通常的形式是这样的：

// something = new MyClass(..);
// JavaScript 也有一个 new 操作符，使用方法看起来也和那些面向类的语言一样，绝大多数开
// 发者都认为 JavaScript 中 new 的机制也和那些语言一样。然而， JavaScript 中 new 的机制实
// 际上和面向类的语言完全不同。


// 首先我们重新定义一下 JavaScript 中的“构造函数”。在 JavaScript 中，构造函数只是一些
// 使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，
// 它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。
// 举例来说，思考一下 Number(..) 作为构造函数时的行为， ES5.1 中这样描述它：

// 15.7.2 Number 构造函数
// 当 Number 在 new 表达式中被调用时，它是一个构造函数：它会初始化新创建的
// 对象。
// 所以，包括内置对象函数（比如 Number(..) ，详情请查看第 3 章）在内的所有函数都可
// 以用 new 来调用，这种函数调用被称为构造函数调用。这里有一个重要但是非常细微的区
// 别：实际上并不存在所谓的“构造函数”， 只有对于函数的“构造调用”。
// 使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。
// 1. 创建（或者说构造）一个全新的对象。
// 2. 这个新对象会被执行[[原型]] 连接。
// 3. 这个新对象会绑定到函数调用的 this。
// 4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。
// 我们现在关心的是第 1 步、第 3 步、第 4 步，所以暂时跳过第 2 步，第 5 章会详细介绍它。
// 思考下面的代码：

function foo(a) {
    this.a = a;
}
var bar = new foo(2);

console.log(bar.a); // 2


// 使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this
// 上。 new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。



// 现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的
// 顺序来进行判断：

// 1. 函数是否在 new 中调用（ new 绑定）？如果是的话 this 绑定的是新创建的对象。

var bar = new foo()

// 2. 函数是否通过 call、 apply（显式绑定）或者硬绑定调用？如果是的话， this 绑定的是
// 指定的对象。

var bar = foo.call(obj2)

// 3. 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话， this 绑定的是那个上
// 下文对象。

var bar = obj1.foo()

// 4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到
// 全局对象。

var bar = foo()

// 就是这样。对于正常的函数调用来说，理解了这些知识你就可以明白 this 的绑定原理了。
// 不过……凡事总有例外。