// 2.2.1　默认绑定
// 首先要介绍的是最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用
// 其他规则时的默认规则。
// 思考一下下面的代码：

function foo() {
    console.log(this.a);
}
var a = 2;
foo(); // 2


// 你应该注意到的第一件事是，声明在全局作用域中的变量（比如 var a = 2）就是全局对
// 象的一个同名属性。它们本质上就是同一个东西，并不是通过复制得到的，就像一个硬币
// 的两面一样。
// 接下来我们可以看到当调用 foo() 时， this.a 被解析成了全局变量 a。为什么？因为在本
// 例中，函数调用时应用了 this 的默认绑定，因此 this 指向全局对象。
// 那么我们怎么知道这里应用了默认绑定呢？可以通过分析调用位置来看看 foo() 是如何调
// 用的。在代码中， foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用
// 默认绑定，无法应用其他规则。
// 如果使用严格模式（ strict mode），那么全局对象将无法使用默认绑定，因此 this 会绑定
// 到 undefined：


function foo() {
    "use strict";
    console.log(this.a);
}
var a = 2;
foo(); // TypeError: this is undefined

// 这里有一个微妙但是非常重要的细节，虽然 this 的绑定规则完全取决于调用位置，但是只
// 有 foo() 运行在非 strict mode 下时，默认绑定才能绑定到全局对象；严格模式下与 foo()
// 的调用位置无关：

function foo() {
    console.log(this.a);
}

var a = 2;

(function () {
    "use strict";
    foo(); // 2
})();

// 通常来说你不应该在代码中混合使用 strict mode 和 non - strict mode。整个
// 程序要么严格要么非严格。然而，有时候你可能会用到第三方库，其严格程
// 度和你的代码有所不同，因此一定要注意这类兼容性细节。