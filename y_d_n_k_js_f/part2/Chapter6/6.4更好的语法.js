// 6.4　更好的语法
// ES6 的 class 语法可以简洁地定义类方法，这个特性让 class 乍看起来更有吸引力（附录
// A 会介绍为什么要避免使用这个特性）：
// class Foo {
//     methodName() { /* .. */ }
// }
// 我们终于可以抛弃定义中的关键字 function 了，对所有 JavaScript 开发者来说真是大快人心！
// 你可能注意到了，在之前推荐的对象关联语法中出现了许多 function，看起来违背了对象
// 关联的简洁性。但是实际上大可不必如此！
// 在 ES6 中 我 们 可 以 在 任 意 对 象 的 字 面 形 式 中 使 用 简 洁 方 法 声 明（ concise method
// declaration）， 所以对象关联风格的对象可以这样声明（和 class 的语法糖一样）：

var LoginController = {
    errors: [],
    getUser() { // 妈妈再也不用担心代码里有 function 了！
        // ...
    },
    getPassword() {
        // ...
    }
    // ...
};

// 唯一的区别是对象的字面形式仍然需要使用“ , ”来分隔元素，而 class 语法不需要。这个
// 区别对于整体的设计来说无关紧要。
// 此外，在 ES6 中，你可以使用对象的字面形式（这样就可以使用简洁方法定义）来
// 改 写 之 前 繁 琐 的 属 性 赋 值 语 法（ 比 如 AuthController 的 定 义 ）， 然 后 用 Object.
//     setPrototypeOf(..) 来修改它的[[Prototype]]：
// 使用更好的对象字面形式语法和简洁方法
var AuthController = {
    errors: [],
    checkAuth() {
        // ...
    },
    server(url, data) {
        // ...
    }
    // ...
};
// 现在把 AuthController 关联到 LoginController
// Object.setPrototypeOf(AuthController, LoginController);

// 使用 ES6 的简洁方法可以让对象关联风格更加人性化（并且仍然比典型的原型风格代码更
// 加简洁和优秀）。你完全不需要使用类就能享受整洁的对象语法！
// 反词法
// 简洁方法有一个非常小但是非常重要的缺点。思考下面的代码：
var Foo = {
    bar() { /*..*/ },
    baz: function baz() { /*..*/ }
};
// 去掉语法糖之后的代码如下所示：
var Foo = {
    bar: function () { /*..*/ },
    baz: function baz() { /*..*/ }
};
// 看 到 区 别 了 吗？ 由 于 函 数 对 象 本 身 没 有 名 称 标 识 符， 所 以 bar() 的 缩 写 形 式
// （ function()..）实际上会变成一个匿名函数表达式并赋值给 bar 属性。相比之下， 具名函
// 数表达式（ function baz()..）会额外给.baz 属性附加一个词法名称标识符 baz。
// 然后呢？在本书第一部分“作用域和闭包”中我们分析了匿名函数表达式的三大主要缺
// 点，下面我们会简单介绍一下这三个缺点，然后和简洁方法定义进行对比。
// 匿名函数没有 name 标识符，这会导致：
// 1. 调试栈更难追踪；
// 2. 自我引用（递归、事件（解除）绑定，等等）更难；
// 3. 代码（稍微）更难理解。
// 简洁方法没有第 1 和第 3 个缺点。
// 去掉语法糖的版本使用的是匿名函数表达式，通常来说并不会在追踪栈中添加 name，但是
// 简洁方法很特殊，会给对应的函数对象设置一个内部的 name 属性，这样理论上可以用在追
// 踪栈中。（ 但是追踪的具体实现是不同的，因此无法保证可以使用。）
// 很不幸，简洁方法无法避免第 2 个缺点，它们不具备可以自我引用的词法标识符。思考下
// 面的代码：
var Foo = {
    bar: function (x) {
        if (x < 10) {
            return Foo.bar(x * 2);
        }

        return x;
    },
    baz: function baz(x) {
        if (x < 10) {
            return baz(x * 2);
        }
        return x;
    }
};
// 在本例中使用 Foo.bar(x * 2) 就足够了，但是在许多情况下无法使用这种方法，比如多个对
// 象通过代理共享函数、使用 this 绑定，等等。这种情况下最好的办法就是使用函数对象的
// name 标识符来进行真正的自我引用。
// 使用简洁方法时一定要小心这一点。如果你需要自我引用的话，那最好使用传统的具名函
// 数表达式来定义对应的函数（ · baz: function baz() {..} · ），不要使用简洁方法。
