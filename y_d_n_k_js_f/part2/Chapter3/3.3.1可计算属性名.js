// 3.3　内容
// 之前我们提到过，对象的内容是由一些存储在特定命名位置的（任意类型的）值组成的，
// 我们称之为属性。
// 需要强调的一点是，当我们说“内容”时，似乎在暗示这些值实际上被存储在对象内部，
// 但是这只是它的表现形式。在引擎内部，这些值的存储方式是多种多样的，一般并不会存
// 在对象容器内部。存储在对象容器内部的是这些属性的名称，它们就像指针（从技术角度
// 来说就是引用）一样，指向这些值真正的存储位置。
// 思考下面的代码：

var myObject = {
    a: 2
};
myObject.a; // 2
myObject["a"]; // 2

// 如果要访问 myObject 中 a 位置上的值，我们需要使用 . 操作符或者 [] 操作符。 .a 语法通
// 常被称为“属性访问”， ["a"] 语法通常被称为“键访问”。实际上它们访问的是同一个位
// 置，并且会返回相同的值 2，所以这两个术语是可以互换的。在本书中我们会使用最常见
// 的术语“属性访问”。
// 这两种语法的主要区别在于 . 操作符要求属性名满足标识符的命名规范，而 [".."] 语法
// 可以接受任意 UTF-8/Unicode 字符串作为属性名。举例来说，如果要引用名称为 "SuperFun!" 的属性，那就必须使用 ["Super-Fun!"] 语法访问，因为 Super-Fun! 并不是一个有效
// 的标识符属性名。
// 此外，由于 [".."] 语法使用字符串来访问属性，所以可以在程序中构造这个字符串，比如说：

var myObject = {
    a: 2
};
var idx;
if (wantA) {
    idx = "a";
}
// 之后
console.log(myObject[idx]); // 2
// 在对象中，属性名永远都是字符串。如果你使用 string（字面量）以外的其他值作为属性
// 名，那它首先会被转换为一个字符串。即使是数字也不例外，虽然在数组下标中使用的的
// 确是数字，但是在对象属性名中数字会被转换成字符串，所以当心不要搞混对象和数组中
// 数字的用法：
var myObject = {};
myObject[true] = "foo";
myObject[3] = "bar";
myObject[myObject] = "baz";
myObject["true"]; // "foo"
myObject["3"]; // "bar"
myObject["[object Object]"]; // "baz"

// 3.3.1　可计算属性名
// 如果你需要通过表达式来计算属性名，那么我们刚刚讲到的 myObject[..] 这种属性访问语
// 法就可以派上用场了，如可以使用 myObject[prefix + name]。但是使用文字形式来声明对
// 象时这样做是不行的。
// ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名：
var prefix = "foo";
var myObject = {
    [prefix + "bar"]: "hello",
    [prefix + "baz"]: "world"
};
myObject["foobar"]; // hello
myObject["foobaz"]; // world

// 可计算属性名最常用的场景可能是 ES6 的符号（ Symbol），本书中不作详细介绍。不过
// 简单来说，它们是一种新的基础数据类型，包含一个不透明且无法预测的值（从技术

// 角度来说就是一个字符串）。一般来说你不会用到符号的实际值（因为理论上来说在不
// 同的 JavaScript 引擎中值是不同的），所以通常你接触到的是符号的名称，比如 Symbol.
// Something（这个名字是我编的）：
var myObject = {
    [Symbol.Something]: "hello world"

}