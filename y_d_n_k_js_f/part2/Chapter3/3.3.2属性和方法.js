// 3.3.2　属性与方法
// 如果访问的对象属性是一个函数，有些开发者喜欢使用不一样的叫法以作区分。由于函数
// 很容易被认为是属于某个对象，在其他语言中，属于对象（也被称为“类”）的函数通常
// 被称为“方法”， 因此把“属性访问”说成是“方法访问”也就不奇怪了。
// 有意思的是， JavaScript 的语法规范也做出了同样的区分。
// 从技术角度来说，函数永远不会“属于”一个对象，所以把对象内部引用的函数称为“方
// 法”似乎有点不妥。
// 确实，有些函数具有 this 引用，有时候这些 this 确实会指向调用位置的对象引用。但是
// 这种用法从本质上来说并没有把一个函数变成一个“方法”，因为 this 是在运行时根据调
// 用位置动态绑定的，所以函数和对象的关系最多也只能说是间接关系。
// 无论返回值是什么类型，每次访问对象的属性就是属性访问。如果属性访问返回的是一个
// 函数，那它也并不是一个“方法”。属性访问返回的函数和其他函数没有任何区别（除了
// 可能发生的隐式绑定 this，就像我们刚才提到的）。
// 举例来说：

function foo() {
    console.log("foo");
}
var someFoo = foo; // 对 foo 的变量引用
var myObject = {
    someFoo: foo
};
foo; // function foo(){..}
someFoo; // function foo(){..}
myObject.someFoo; // function foo(){..}

// someFoo 和 myObject.someFoo 只是对于同一个函数的不同引用，并不能说明这个函数是特
// 别的或者“属于”某个对象。如果 foo() 定义时在内部有一个 this 引用，那这两个函数引
// 108 ｜ 第 3 章
// 用的唯一区别就是 myObject.someFoo 中的 this 会被隐式绑定到一个对象。无论哪种引用
// 形式都不能称之为“方法”。
// 或许有人会辩解说，函数并不是在定义时成为方法，而是在被调用时根据调用位置的不同
// （是否具有上下文对象——详见第 2 章）成为方法。即便如此，这种说法仍然有些不妥。
// 最保险的说法可能是，“ 函数”和“方法”在 JavaScript 中是可以互换的。
// ES6 增加了 super 引用，一般来说会被用在 class 中（参见附录 A）。 super
// 的行为似乎更有理由把 super 绑定的函数称为“方法”。但是再说一次，这
// 些只是一些语义（和技术）上的微妙差别，本质是一样的。
// 即使你在对象的文字形式中声明一个函数表达式，这个函数也不会“属于”这个对象——
// 它们只是对于相同函数对象的多个引用。

var myObject = {
    foo: function () {
        console.log("foo");
    }
};
var someFoo = myObject.foo;
someFoo; // function foo(){..}
myObject.foo; // function foo(){..}

// 第 6 章会介绍本例对象的文字形式中声明函数的语法，这是 ES6 增加的一种
// 简易函数声明语法。