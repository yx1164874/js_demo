// 4.3　类的继承
// 在面向类的语言中，你可以先定义一个类，然后定义一个继承前者的类。
// 后者通常被称为“子类”，前者通常被称为“父类”。这些术语显然是类比父母和孩子，不
// 过在意思上稍有扩展，你很快就会看到。
// 对于父母的亲生孩子来说，父母的基因特性会被复制给孩子。显然，在大多数生物的繁殖
// 系统中，双亲都会贡献等量的基因给孩子。但是在编程语言中，我们假设只有一个父类。
// 一旦孩子出生，他们就变成了单独的个体。虽然孩子会从父母继承许多特性，但是他是一
// 个独一无二的存在。如果孩子的头发是红色，父母的头发未必是红的，也不会随之变红，
// 混合对象“类” ｜ 131
// 二者之间没有直接的联系。
// 同理，定义好一个子类之后，相对于父类来说它就是一个独立并且完全不同的类。子类会
// 包含父类行为的原始副本，但是也可以重写所有继承的行为甚至定义新行为。
// 非常重要的一点是，我们讨论的父类和子类并不是实例。父类和子类的比喻容易造成一
// 些误解，实际上我们应当把父类和子类称为父类 DNA 和子类 DNA。我们需要根据这些
// DNA 来创建（或者说实例化）一个人，然后才能和他进行沟通。
// 好了，我们先抛开现实中的父母和孩子，来看一个稍有不同的例子：不同类型的交通工
// 具。这是一个非常典型（并且经常被抱怨）的讲解继承的例子。
// 首先回顾一下本章前面部分提出的 Vehicle 和 Car 类。思考下面关于类继承的伪代码：

class Vehicle {
    engines = 1
    ignition() {
        output("Turning on my engine.");
    }
    drive() {
        ignition();
        output("Steering and moving forward!")
    }
}
class Car inherits Vehicle {
    wheels = 4
    drive() {
        inherited: drive()
        output("Rolling on all ", wheels, " wheels!")
    }
}
class SpeedBoat inherits Vehicle {
    engines = 2
    ignition() {
        output("Turning on my ", engines, " engines.")
    }
    pilot() {
        inherited: drive()
        output("Speeding through the water with ease!")
    }
}

// 为了方便理解并缩短代码，我们省略了这些类的构造函数。
// 我们通过定义 Vehicle 类来假设一种发动机，一种点火方式，一种驾驶方法。但是你不可
// 能制造一个通用的“交通工具”， 因为这个类只是一个抽象的概念。
// 接下来我们定义了两类具体的交通工具： Car 和 SpeedBoat。它们都从 Vehicle 继承了通用
// 的特性并根据自身类别修改了某些特性。汽车需要四个轮子，快艇需要两个发动机，因此
// 它必须启动两个发动机的点火装置。

// 4.3.1　多态
// Car 重写了继承自父类的 drive() 方法，但是之后 Car 调用了 inherited: drive() 方法，
// 这表明 Car 可以引用继承来的原始 drive() 方法。快艇的 pilot() 方法同样引用了原始
// drive() 方法。
// 这个技术被称为多态或者虚拟多态。在本例中，更恰当的说法是相对多态。
// 多态是一个非常广泛的话题，我们现在所说的“相对”只是多态的一个方面：任何方法都
// 可以引用继承层次中高层的方法（无论高层的方法名和当前方法名是否相同）。之所以说
// “相对”是因为我们并不会定义想要访问的绝对继承层次（或者说类），而是使用相对引用
// “查找上一层”。
// 在 许 多 语 言 中 可 以 使 用 super 来 代 替 本 例 中 的 inherited: ， 它 的 含 义 是“ 超 类 ”
// （ superclass），表示当前类的父类 / 祖先类。
// 多态的另一个方面是，在继承链的不同层次中一个方法名可以被多次定义，当调用方法时
// 会自动选择合适的定义。
// 在之前的代码中就有两个这样的例子： drive() 被定义在 Vehicle 和 Car 中， ignition() 被
// 定义在 Vehicle 和 SpeedBoat 中。
// 在传统的面向类的语言中 super 还有一个功能，就是从子类的构造函数中通过
// super 可以直接调用父类的构造函数。通常来说这没什么问题，因为对于真正
// 的类来说，构造函数是属于类的。然而，在 JavaScript 中恰好相反——实际
// 上“ 类” 是属于构造函数的（类似 Foo.prototype...这样的类型引用）。由于
// JavaScript 中父类和子类的关系只存在于两者构造函数对应的.prototype 对象
// 中，因此它们的构造函数之间并不存在直接联系，从而无法简单地实现两者的
// 相对引用（在 ES6 的类中可以通过 super 来“ 解决” 这个问题，参见附录 A）。


// 我们可以在 ignition() 中看到多态非常有趣的一点。在 pilot() 中通过相对多态引用了
// （继承来的） Vehicle 中的 drive() 。但是那个 drive() 方法直接通过名字（而不是相对引
// 用）引用了 ignotion() 方法。
// 那么语言引擎会使用哪个 ignition() 呢， Vehicle 的还是 SpeedBoat 的？实际上它会使用
// SpeedBoat 的 ignition() 。如果你直接实例化了 Vehicle 类然后调用它的 drive() ，那语言
// 引擎就会使用 Vehicle 中的 ignition() 方法。
// 换言之， ignition() 方法定义的多态性取决于你是在哪个类的实例中引用它。
// 这似乎是一个过于深入的学术细节，但是只有理解了这个细节才能理解 JavaScript 中类似
// （但是并不相同）的[[Prototype]] 机制。
// 在子类（而不是它们创建的实例对象！）中也可以相对引用它继承的父类，这种相对引用
// 通常被称为 super。
// 还记得之前的那张图吗？
// 注意这些实例（ a1、 a2、 b1 和 b2）和继承（ Bar），箭头表示复制操作。
// 从概念上来说，子类 Bar 应当可以通过相对多态引用（或者说 super）来访问父类 Foo 中
// 的行为。需要注意，子类得到的仅仅是继承自父类行为的一份副本。子类对继承到的一个
// 方法进行“重写”，不会影响父类中的方法，这两个方法互不影响，因此才能使用相对多
// 态引用访问父类中的方法（如果重写会影响父类的方法，那重写之后父类中的原始方法就
// 不存在了，自然也无法引用）。
// 多态并不表示子类和父类有关联，子类得到的只是父类的一份副本。类的继承其实就是
// 复制。

// 4.3.2　多重继承
// 还记得我们之前关于父类、子类和 DNA 的讨论吗？当时我们说这个比喻不太恰当，因为
// 在现实中绝大多数后代是由双亲产生的。如果类可以继承两个类，那看起来就更符合现实
// 的比喻了。
// 有些面向类的语言允许你继承多个“父类”。多重继承意味着所有父类的定义都会被复制
// 到子类中。
// 从表面上来，对于类来说这似乎是一个非常有用的功能，可以把许多功能组合在一起。然
// 而，这个机制同时也会带来很多复杂的问题。如果两个父类中都定义了 drive() 方法的话，
// 子类引用的是哪个呢？难道每次都需要手动指定具体父类的 drive() 方法吗？这样多态继
// 承的很多优点就存在了。
// 除此之外，还有一种被称为钻石问题的变种。在钻石问题中，子类 D 继承自两个父类（ B
// 和 C），这两个父类都继承自 A。如果 A 中有 drive() 方法并且 B 和 C 都重写了这个方法
// （多态）， 那当 D 引用 drive() 时应当选择哪个版本呢（ B: drive() 还是 C: drive() ）？
// 这些问题远比看上去要复杂得多。之所以要介绍这些问题，主要是为了和 JavaScript 的机
// 制进行对比。
// 相比之下， JavaScript 要简单得多：它本身并不提供“多重继承”功能。许多人认为这是
// 件好事，因为使用多重继承的代价太高。然而这无法阻挡开发者们的热情，他们会尝试各
// 种各样的办法来实现多重继承，我们马上就会看到。
