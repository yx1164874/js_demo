// 5.5　小结
// 如果要访问对象中并不存在的一个属性，[[Get]] 操作（参见第 3 章）就会查找对象内部
// [[Prototype]] 关联的对象。这个关联关系实际上定义了一条“原型链”（有点像嵌套的作

// 用域链），在查找属性时会对它进行遍历。
// 所有普通对象都有内置的 Object.prototype，指向原型链的顶端（比如说全局作用域），如
// 果在原型链中找不到指定的属性就会停止。 toString() 、 valueOf() 和其他一些通用的功能
// 都存在于 Object.prototype 对象上，因此语言中所有的对象都可以使用它们。
// 关联两个对象最常用的方法是使用 new 关键词进行函数调用，在调用的 4 个步骤（第 2
// 章）中会创建一个关联其他对象的新对象。
// 使用 new 调用函数时会把新对象的.prototype 属性关联到“其他对象”。带 new 的函数调用
// 通常被称为“构造函数调用”，尽管它们实际上和传统面向类语言中的类构造函数不一样。
// 虽然这些 JavaScript 机制和传统面向类语言中的“类初始化”和“类继承”很相似，但
// 是 JavaScript 中的机制有一个核心区别，那就是不会进行复制，对象之间是通过内部的
// [[Prototype]] 链关联的。
// 出于各种原因，以“继承”结尾的术语（包括“原型继承”）和其他面向对象的术语都无
// 法帮助你理解 JavaScript 的真实机制（不仅仅是限制我们的思维模式）。
// 相比之下，“ 委托”是一个更合适的术语，因为对象之间的关系不是复制而是委托。