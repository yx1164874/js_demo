#1.2.1　演员表

##引擎
从头到尾负责整个 JavaScript 程序的编译及执行过程。

##编译器
引擎的好朋友之一，负责语法分析及代码生成等脏活累活（详见前一节的内容）。

##作用域
引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查
询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

#1.2.2　对话
当你看见 var a = 2; 这段程序时，很可能认为这是一句声明。但我们的新朋友引擎却不这
么看。事实上，引擎认为这里有两个完全不同的声明，一个由编译器在编译时处理，另一

个则由引擎在运行时处理。

下面我们将 var a = 2; 分解，看看引擎和它的朋友们是如何协同工作的。
编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。但是当编
译器开始进行代码生成时，它对这段程序的处理方式会和预期的有所不同。
可以合理地假设编译器所产生的代码能够用下面的伪代码进行概括：“为一个变量分配内
存，将其命名为 a，然后将值 2 保存进这个变量。”然而，这并不完全正确。
事实上编译器会进行如下处理。
1. 遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的
集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作
用域的集合中声明一个新的变量，并命名为 a。
2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值
操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的
变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量（查看 1.3
节）。
如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异
常！


##总结： 
变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如
果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对
它赋值。


LHS 和 RHS 的含义是“赋值操作的左侧或右侧”并不一定意味着就是“ =
赋值操作符的左侧或右侧”。赋值操作还有其他几种形式，因此在概念上最
好将其理解为“赋值操作的目标是谁（ LHS）”以及“谁是赋值操作的源头
（ RHS）

如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError
异常。值得注意的是， ReferenceError 是非常重要的异常类型。


ES5 中引入了“严格模式”。同正常模式，或者说宽松 / 懒惰模式相比，严格模式在行为上
有很多不同。其中一个不同的行为是严格模式禁止自动或隐式地创建全局变量。因此，在
严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询
失败时类似的 ReferenceError 异常。
接下来，如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，
比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的
属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError。
ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对
结果的操作是非法或不合理的



作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对
变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。
作用域是什么 ｜ 13
赋值操作符会导致 LHS 查询。 ＝操作符或调用函数时传入参数的操作都会导致关联作用域
的赋值操作。
JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 var a = 2 这样的声
明会被分解成两个独立的步骤：
1. 首先， var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。
2. 接下来， a = 2 会查询（ LHS 查询）变量 a 并对其进行赋值。
LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所
需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层
楼）， 最后抵达全局作用域（顶层），无论找到或没找到都将停止。
不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式
地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛
出 ReferenceError 异常（严格模式下）。