#第 1 章介绍过，大部分标准语言编译器的第一个工作阶段叫作词法化（也叫单词化）。回
忆一下，词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋
予单词语义。
这个概念是理解词法作用域及其名称来历的基础。
简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写
代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域
不变（大部分情况下是这样的）



#查找
作用域气泡的结构和互相之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息
来查找标识符的位置。
在上一个代码片段中，引擎执行 console.log(..) 声明，并查找 a、 b 和 c 三个变量的引
用。它首先从最内部的作用域，也就是 bar(..) 函数的作用域气泡开始查找。引擎无法在
这里找到 a，因此会去上一级到所嵌套的 foo(..) 的作用域中继续查找。在这里找到了 a，
因此引擎使用了这个引用。对 b 来讲也是一样的。而对 c 来说，引擎在 bar(..) 中就找到
了它。
如果 a、 c 都存在于 bar(..) 和 foo(..) 的内部， console.log(..) 就可以直接使用 bar(..)
中的变量，而无需到外面的 foo(..) 中查找。
作用域查找会在找到第一个匹配的标识符时停止。 在多层的嵌套作用域中可以定义同名的
标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，
作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见
第一个匹配的标识符为止


全局变量会自动成为全局对象（比如浏览器中的 window 对象）的属性，因此
可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引
用来对其进行访问。
window.a
通过这种技术可以访问那些被同名变量所遮蔽的全局变量。但非全局的变量
如果被遮蔽了，无论如何都无法被访问到。
无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处
的位置决定。
词法作用域查找只会查找一级标识符，比如 a、 b 和 c。如果代码中引用了 foo.bar.baz，
词法作用域查找只会试图查找 foo 标识符，找到这个变量后，对象属性访问规则会分别接
管对 bar 和 baz 属性的访问。