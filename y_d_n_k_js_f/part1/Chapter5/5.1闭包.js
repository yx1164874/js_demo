// 5.1　启示
// 对于那些有一点 JavaScript 使用经验但从未真正理解闭包概念的人来说，理解闭包可以看
// 作是某种意义上的重生，但是需要付出非常多的努力和牺牲才能理解这个概念。
// 回忆我前几年的时光，大量使用 JavaScript 但却完全不理解闭包是什么。总是感觉这门语
// 言有其隐蔽的一面，如果能够掌握将会功力大涨，但讽刺的是我始终无法掌握其中的门
// 道。还记得我曾经大量阅读早期框架的源码，试图能够理解闭包的工作原理。现在还能回
// 忆起我的脑海中第一次浮现出关于“模块模式”相关概念时的激动心情。
// 那时我无法理解并且倾尽数年心血来探索的，也就是我马上要传授给你的秘诀： JavaScript
// 注 1： Douglas Crockford 是 Web 开发领域最知名的技术权威之一， ECMA JavaScript 2.0 标准化委员会委员，
// 被 JavaScript 之父 Brendan Eich 称为 JavaScript 界的宗师。——译者注




// 中闭包无处不在，你只需要能够识别并拥抱它。 闭包并不是一个需要学习新的语法或模式
// 才能使用的工具，它也不是一件必须接受像 Luke2 一样的原力训练才能使用和掌握的武器。
// 闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意
// 识地创建闭包。闭包的创建和使用在你的代码中随处可见。你缺少的是根据你自己的意愿
// 来识别、拥抱和影响闭包的思维环境。
// 最后你恍然大悟：原来在我的代码中已经到处都是闭包了，现在我终于能理解它们了。理
// 解闭包就好像 Neo3 第一次见到矩阵 4 一样


// 5.2　实质问题
// 好了，夸张和浮夸的电影比喻已经够多了。
// 下面是直接了当的定义，你需要掌握它才能理解和识别闭包：
// 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用
// 域之外执行。
// 下面用一些代码来解释这个定义。


// function foo() {
//     var a = 2;
//     function bar() {
//         console.log(a); // 2
//     }
//     bar();
// }
// foo();


// 这段代码看起来和嵌套作用域中的示例代码很相似。基于词法作用域的查找规则，函数
// bar() 可以访问外部作用域中的变量 a（这个例子中的是一个 RHS 引用查询）。
// 这是闭包吗？
// 技术上来讲， 也许是。但根据前面的定义， 确切地说并不是。我认为最准确地用来解释
// bar() 对 a 的引用的方法是词法作用域的查找规则，而这些规则只是闭包的一部分。（但却
// 是非常重要的一部分！）


// 从纯学术的角度说，在上面的代码片段中，函数 bar() 具有一个涵盖 foo() 作用域的闭包
// （事实上，涵盖了它能访问的所有作用域，比如全局作用域）。也可以认为 bar() 被封闭在
// 了 foo() 的作用域中。为什么呢？原因简单明了，因为 bar() 嵌套在 foo() 内部。
// 但是通过这种方式定义的闭包并不能直接进行观察，也无法明白在这个代码片段中闭包是
// 如何工作的。我们可以很容易地理解词法作用域，而闭包则隐藏在代码之后的神秘阴影
// 里，并不那么容易理解。
// 下面我们来看一段代码，清晰地展示了闭包：


// function foo(){
//     var a='hello world'
//     function baz(){
//         console.log(a)
//     }
//     return baz
// }
// boo=foo();
// boo()



// 函数 bar() 的词法作用域能够访问 foo() 的内部作用域。然后我们将 bar() 函数本身当作
// 一个值类型进行传递。在这个例子中，我们将 bar 所引用的函数对象本身当作返回值。
// 在 foo() 执行后，其返回值（也就是内部的 bar() 函数）赋值给变量 baz 并调用 baz() ，实
// 际上只是通过不同的标识符引用调用了内部的函数 bar() 。
// bar() 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方
// 执行。
// 在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃
// 圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很
// 自然地会考虑对其进行回收。
// 而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此
// 没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用。
// 拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一
// 直存活，以供 bar() 在之后任何时间进行引用。
// bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。
// 因此，在几微秒之后变量 baz 被实际调用（调用内部函数 bar），不出意料它可以访问定义


// 时的词法作用域，因此它也可以如预期般访问变量 a。
// 这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的
// 词法作用域。
// 当然，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到
// 闭包。


// function foo() {
//     var a = 2;
//     function baz() {
//         console.log(a); // 2
//     }
//     bar(baz);
// }
// function bar(fn) {
//     fn(); // 妈妈快看呀，这就是闭包！
// }


// 把内部函数 baz 传递给 bar，当调用这个内部函数时（现在叫作 fn），它涵盖的 foo() 内部
// 作用域的闭包就可以观察到了，因为它能够访问 a。
// 传递函数当然也可以是间接的。


var fn;
function foo() {
    var a = 'hello wolrd';
    function bar() {
        console.log(a);
    }
    fn = bar;
}
function baz() {
    fn()
}
foo();
baz();



// 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用
// 域的引用，无论在何处执行这个函数都会使用闭包。


// 5.3　现在我懂了
// 前面的代码片段有点死板，并且为了解释如何使用闭包而人为地在结构上进行了修饰。但
// 我保证闭包绝不仅仅是一个好玩的玩具。你已经写过的代码中一定到处都是闭包的身影。
// 现在让我们来搞懂这个事实。

function wait(message) {

    setTimeout(function timer() {
        console.log(message);
    }, 1000);
}
wait("Hello, closure!");

// 将一个内部函数（名为 timer）传递给 setTimeout(..) 。 timer 具有涵盖 wait(..) 作用域
// 的闭包，因此还保有对变量 message 的引用。
// wait(..) 执行 1000 毫秒后，它的内部作用域并不会消失， timer 函数依然保有 wait(..)
// 作用域的闭包。
// 深入到引擎的内部原理中，内置的工具函数 setTimeout(..) 持有对一个参数的引用，这个
// 参数也许叫作 fn 或者 func，或者其他类似的名字。引擎会调用这个函数，在例子中就是
// 内部的 timer 函数，而词法作用域在这个过程中保持完整。
// 这就是闭包。
// 或者，如果你很熟悉 jQuery（或者其他能说明这个问题的 JavaScript 框架），可以思考下面
// 的代码：

// function setupBot(name, selector) {
//     $(selector).click(function activator() {
//         console.log("Activating: " + name);
//     });
// }
// setupBot("Closure Bot 1", "#bot_1");
// setupBot("Closure Bot 2", "#bot_2");

// 我不知道你会写什么样的代码，但是我写的代码负责控制由闭包机器人组成的整个全球无
// 人机大军，这是完全可以实现的！
// 玩笑开完了，本质上无论何时何地，如果将函数（访问它们各自的词法作用域）当作第一
// 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、
// Ajax 请求、跨窗口通信、 Web Workers 或者任何其他的异步（或者同步）任务中，只要使
// 用了回调函数，实际上就是在使用闭包！

// 第 3 章介绍了 IIFE 模式。通常认为 IIFE 是典型的闭包例子，但根据先前对
// 闭包的定义，我并不是很同意这个观点。


var a = 2;
(function IIFE() {
    console.log(a);
})();


// 虽然这段代码可以正常工作，但严格来讲它并不是闭包。为什么？因为函数（示例代码中
// 的 IIFE）并不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行（而
// 外部作用域，也就是全局作用域也持有 a）。 a 是通过普通的词法作用域查找而非闭包被发
// 现的。
// 尽管技术上来讲，闭包是发生在定义时的，但并不非常明显，就好像六祖慧能所说：“既
// 非风动，亦非幡动，仁者心动耳。” 5。
// 尽管 IIFE 本身并不是观察闭包的恰当例子，但它的确创建了闭包，并且也是最常用来创建
// 可以被封闭起来的闭包的工具。因此 IIFE 的确同闭包息息相关，即使本身并不会真的使用
// 闭包。
// 亲爱的读者，现在把书放下，我有一个任务要给你。打开你最近写的 JavaScript 代码，找
// 到其中的函数类型的值并指出哪里已经使用了闭包，即使你以前可能并不知道这就是
// 闭包。
// 等你呦！
// 现在你懂了吧！


// 5.4　循环和闭包
// 要说明闭包， for 循环是最常见的例子。
for (var i = 1; i <= 5; i++) {
    setTimeout(function timer() {
        console.log(i);
    }, i * 1000);
}
// 注 5： 原文为 it’s a tree falling in the forest with no one around to hear it，同六祖慧能的风幡之动禅喻近义，比
// 喻客观存在和观察认知之间的关系。——译者注


// 由于很多开发者对闭包的概念认识得并不是很清楚，因此当循环内部包含函
// 数定义时，代码格式检查器经常发出警告。我们在这里介绍如何才能正确地
// 使用闭包并发挥它的威力，但是代码格式检查器并没有那么灵敏，它会假设
// 你并不真正了解自己在做什么，所以无论如何都会发出警告。
// 正常情况下，我们对这段代码行为的预期是分别输出数字 1~5，每秒一次，每次一个。
// 但实际上，这段代码在运行时会以每秒一次的频率输出五次 6。
// 这是为什么？
// 首先解释 6 是从哪里来的。这个循环的终止条件是 i 不再 <= 5。条件首次成立时 i 的值是

// 6。 因此，输出显示的是循环结束时 i 的最终值。
// 仔细想一下，这好像又是显而易见的，延迟函数的回调会在循环结束时才执行。事实上，
// 当定时器运行时即使每个迭代中执行的是 setTimeout(.., 0) ，所有的回调函数依然是在循
// 环结束后才会被执行，因此会每次输出一个 6 出来。
// 这里引伸出一个更深入的问题，代码中到底有什么缺陷导致它的行为同语义所暗示的不一
// 致呢？
// 缺陷是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个 i 的副本。但是
// 根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，
// 但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i。
// 这样说的话， 当然所有函数共享一个 i 的引用。循环结构让我们误以为背后还有更复杂的
// 机制在起作用，但实际上没有。如果将延迟函数的回调重复定义五次，完全不使用循环，
// 那它同这段代码是完全等价的。
// 下面回到正题。缺陷是什么？我们需要更多的闭包作用域，特别是在循环的过程中每个迭
// 代都需要一个闭包作用域。
// 第 3 章介绍过， IIFE 会通过声明并立即执行一个函数来创建作用域。
// 我们来试一下：


for (var i = 1; i <= 5; i++) {
    (function () {
        setTimeout(function timer() {
            console.log(i);
        }, i * 1000);
    })();
}

// 这样能行吗？试试吧，我等着你

// 我不卖关子了。 这样不行。但是为什么呢？我们现在显然拥有更多的词法作用域了。的确
// 每个延迟函数都会将 IIFE 在每次迭代中创建的作用域封闭起来。
// 如果作用域是空的，那么仅仅将它们进行封闭是不够的。仔细看一下，我们的 IIFE 只是一
// 个什么都没有的空作用域。它需要包含一点实质内容才能为我们所用。
// 它需要有自己的变量，用来在每个迭代中储存 i 的值：


for (var i = 1; i <= 5; i++) {
    (function () {
        var j = i;
        setTimeout(function timer() {
            console.log(j);
        }, j * 1000);
    })();
}


// 行了！它能正常工作了！ 。
// 可以对这段代码进行一些改进：


for (var i = 1; i <= 5; i++) {
    (function (j) {
        setTimeout(function timer() {
            console.log(j);
        }, j * 1000);
    })(i);
}


// 当然，这些 IIFE 也不过就是函数，因此我们可以将 i 传递进去，如果愿意的话可以将变量
// 名定为 j，当然也可以还叫作 i。无论如何这段代码现在可以工作了。
// 在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的
// 作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。
// 问题解决啦


// 重返块作用域
// 仔细思考我们对前面的解决方案的分析。我们使用 IIFE 在每次迭代时都创建一个新的作用
// 域。换句话说，每次迭代我们都需要一个块作用域。第 3 章介绍了 let 声明，可以用来劫
// 持块作用域，并且在这个块作用域中声明一个变量。
// 本质上这是将一个块转换成一个可以被关闭的作用域。 因此，下面这些看起来很酷的代码
// 就可以正常运行了：

for (var i = 1; i <= 5; i++) {
    let j = i; // 是的，闭包的块作用域！
    setTimeout(function timer() {
        console.log(j);
    }, j * 1000);
}

// 但是，这还不是全部！ （我用 Bob Barker6 的声音说道） for 循环头部的 let 声明还会有一
// 个特殊的行为。这个行为指出变量在循环过程中不止被声明一次， 每次迭代都会声明。随
// 后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。

for (let i = 1; i <= 5; i++) {
    setTimeout(function timer() {
        console.log(i);
    }, i * 1000);
}

// 很酷是吧？块作用域和闭包联手便可天下无敌。不知道你是什么情况，反正这个功能让我
// 成为了一名快乐的 JavaScript 程序员。