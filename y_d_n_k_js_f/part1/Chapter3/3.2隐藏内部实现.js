// 3.2　隐藏内部实现

// 对函数的传统认知就是先声明一个函数，然后再向里面添加代码。但反过来想也可以带来
// 一些启示：从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际
// 上就是把这些代码“隐藏”起来了。
// 实际的结果就是在这个代码片段的周围创建了一个作用域气泡，也就是说这段代码中的任
// 何声明（变量或函数）都将绑定在这个新创建的包装函数的作用域中，而不是先前所在的
// 作用域中。换句话说，可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域
// 来“隐藏”它们。
// 为什么“隐藏”变量和函数是一个有用的技术？
// 24 ｜ 第 3 章
// 有很多原因促成了这种基于作用域的隐藏方法。它们大都是从最小特权原则中引申出来
// 的，也叫最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必
// 要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。
// 这个原则可以延伸到如何选择作用域来包含变量和函数。如果所有变量和函数都在全局作
// 用域中，当然可以在所有的内部嵌套作用域中访问到它们。但这样会破坏前面提到的最小
// 特权原则，因为可能会暴漏过多的变量或函数，而这些变量或函数本应该是私有的，正确
// 的代码应该是可以阻止对这些变量或函数进行访问的。
// 例如：
function doSomething(a) {
    b = a + doSomethingElse(a * 2);
    console.log(b * 3);
}
function doSomethingElse(a) {
    return a - 1;
}
var b;

doSomething(2); // 15


// 在这个代码片段中，变量 b 和函数 doSomethingElse(..) 应该是 doSomething(..) 内部具体
// 实现的“私有”内容。给予外部作用域对 b 和 doSomethingElse(..) 的“访问权限”不仅
// 没有必要，而且可能是“危险”的，因为它们可能被有意或无意地以非预期的方式使用，
// 从而导致超出了 doSomething(..) 的适用条件。更“合理”的设计会将这些私有的具体内
// 容隐藏在 doSomething(..) 内部，例如：


function doSomething(a) {
    function doSomethingElse(a) {
        return a - 1;
    }
    var b;
    b = a + doSomethingElse(a * 2);
    console.log(b * 3);
}

doSomething(2); // 15
// 现在， b 和 doSomethingElse(..) 都无法从外部被访问，而只能被 doSomething(..) 所控制。
// 功能性和最终效果都没有受影响，但是设计上将具体内容私有化了，设计良好的软件都会
// 依此进行实现。