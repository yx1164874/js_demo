// 3.1　函数中的作用域
// 对于前面提出的问题，最常见的答案是 JavaScript 具有基于函数的作用域，意味着每声明
// 一个函数都会为其自身创建一个气泡，而其他结构都不会创建作用域气泡。但事实上这并
// 不完全正确，下面我们来看一下。
// 首先需要研究一下函数作用域及其背后的一些内容。
// 考虑下面的代码：



function foo(a) {
var b = 2;
// 一些代码
function bar() {
// ...
}
// 函数作用域和块作用域 ｜ 23
// 更多的代码
var c = 3;
}
// 在这个代码片段中， foo(..) 的作用域气泡中包含了标识符 a、 b、 c 和 bar。无论标识符
// 声明出现在作用域中的何处，这个标识符所代表的变量或函数都将附属于所处作用域的气
// 泡。我们将在下一章讨论具体的原理。
// bar(..) 拥有自己的作用域气泡。全局作用域也有自己的作用域气泡，它只包含了一个标
// 识符： foo。
// 由于标识符 a、 b、 c 和 bar 都附属于 foo(..) 的作用域气泡，因此无法从 foo(..) 的外部
// 对它们进行访问。也就是说，这些标识符全都无法从全局作用域中进行访问，因此下面的
// 代码会导致 ReferenceError 错误：

bar(); // 失败
console.log( a, b, c ); // 三个全都失败


// 但是，这些标识符（ a、 b、 c、 foo 和 bar）在 foo(..) 的内部都是可以被访问的，同样在
// bar(..) 内部也可以被访问（假设 bar(..) 内部没有同名的标识符声明）。
// 函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复
// 用（事实上在嵌套的作用域中也可以使用）。这种设计方案是非常有用的，能充分利用
// JavaScript 变量可以根据需要改变值类型的“动态”特性。
// 但与此同时，如果不细心处理那些可以在整个作用域范围内被访问的变量，可能会带来意
// 想不到的问题。